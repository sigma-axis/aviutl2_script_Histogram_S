--[[
MIT License
Copyright (c) 2025 sigma-axis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

https://mit-license.org/
]]
--information:Histogram_S ヒストグラム表示スクリプト v1.00 (for beta22a) by σ軸
--label:編集補助\色調整
--track@width:幅,256,1024,256,1
--track@height:高さ,16,400,100,1
--select@target:対象=1,フレームバッファ(アルファ値なし)=0,フレームバッファ(アルファ値あり)=1,レイヤー(絶対指定)=2,レイヤー(相対指定)=3
--value@target_layer:レイヤー指定,-1
--group:グラフ設定,true
--select@space:色空間=1,XYZ=0,RGB=1,sRGB=2,Oklab=3,OKLCH=4,YUV(BT.601)=5,YUV(BT.709)=6,YUV(BT.2020)=7,HSV(円柱)=8,HSV(円錐)=9,HSL(円柱)=10,HSL(双円錐)=11
--check@hue_weighted:色相を彩度で重み付け,false
--check@alpha:アルファ値,false
--track@amplify:拡大率,0,1600,100,0.01
--select@scale:スケール=0,線形スケール=0,対数スケール=1
--track@mollify:平滑化,0,15,0,1
--group:表示設定,false
--color@col_draw:描画色,0xffffff
--color@col_back:背景色,0x000000
--track@alpha_back:背景透明度,0,100,0,0.01
--check@colorful:色を付ける,true
--check@grid:罫線,true
--track@pos_labels:ラベル位置,-100,100,-100,0.001
--select@hide_mode:表示モード=1,常に表示=0,動画出力中は非表示=1,プレビュー再生中も非表示=2
--[[pixelshader@to_xyz:
Texture2D src : register(t0);
float3 to_lin(float3 c)
{
	static const float4 K = { 0.055, 1 / 1.055, 1 / 12.92, 0.04045 };
	return abs(c) <= K.w ? K.z * c : sign(c) * pow((abs(c) + K.x) * K.y, 2.4);
}
static const float3x3 M = {
	0.4124, 0.3576, 0.1805,
	0.2126, 0.7152, 0.0722,
	0.0193, 0.1192, 0.9505
};
float4 to_xyz(float4 pos : SV_Position) : SV_Target
{
	float4 col = src.Load(int3(pos.xy, 0));
	col.xyz = mul(M, to_lin(col.a > 0 ? col.rgb / col.a : 0));
	return col;
}
]]
--[[pixelshader@un_alpha:
Texture2D src : register(t0);
float4 un_alpha(float4 pos : SV_Position) : SV_Target
{
	float4 col = src.Load(int3(pos.xy, 0));
	col.rgb = col.a > 0 ? col.rgb / col.a : 0;
	return col;
}
]]
--[[pixelshader@to_srgb:
Texture2D src : register(t0);
float3 to_lin(float3 c)
{
	static const float4 K = { 0.055, 1 / 1.055, 1 / 12.92, 0.04045 };
	return abs(c) <= K.w ? K.z * c : sign(c) * pow((abs(c) + K.x) * K.y, 2.4);
}
float4 to_srgb(float4 pos : SV_Position) : SV_Target
{
	float4 col = src.Load(int3(pos.xy, 0));
	col.rgb = to_lin(col.a > 0 ? col.rgb / col.a : 0);
	return col;
}
]]
--[[pixelshader@to_oklab:
Texture2D src : register(t0);
cbuffer constant0 : register(b0) {
	float cylindrical_f;
};
float3 to_lin(float3 c)
{
	static const float4 K = { 0.055, 1 / 1.055, 1 / 12.92, 0.04045 };
	return abs(c) <= K.w ? K.z * c : sign(c) * pow((abs(c) + K.x) * K.y, 2.4);
}
static const float3x3 m1_rgb = {
	0.41222146, 0.53633255, 0.051445995,
	0.2119035 , 0.6806995 , 0.10739696 ,
	0.08830246, 0.28171885, 0.6299787
}, m2 = {
	0.21045426 ,  0.7936178 , -0.004072047,
	1.9779985  , -2.4285922 ,  0.4505937  ,
	0.025904037,  0.78277177, -0.80867577
};
static const float ab_boost = 1.50;
float3 to_lms_gamma(float3 c)
{
	c = mul(m1_rgb, c);
	return sign(c) * pow(abs(c), 1 / 3.0);
}
float4 to_oklab(float4 pos : SV_Position) : SV_Target
{
	float4 col = src.Load(int3(pos.xy, 0));
	col.xyz = mul(m2, to_lms_gamma(to_lin(col.a > 0 ? col.rgb / col.a : 0)));
	if (cylindrical_f > 0) {
		static const float pi = 3.1415927;
		float C = length(col.yz),
			h = C > 1 / 4096.0 ? 0.5 + atan2(-col.z, -col.y) / (2 * pi) : -32768.0;
		col.yz = float2(2 * ab_boost * C, h);
	}
	else {
		col.yz *= ab_boost;
		col.yz += 0.5;
	}
	return col;
}
]]
--[[pixelshader@to_yuv:
Texture2D src : register(t0);
cbuffer constant0 : register(b0) {
	float3x3 mat;
};
float4 to_yuv(float4 pos : SV_Position) : SV_Target
{
	float4 col = src.Load(int3(pos.xy, 0));
	col.xyz = mul(mat, col.a > 0 ? col.rgb / col.a : 0);
	col.yz += 0.5;
	return col;
}
]]
--[[pixelshader@to_hsvl:
Texture2D src : register(t0);
cbuffer constant0 : register(b0) {
	float model_f;
};
// modified from: https://gist.github.com/983/e170a24ae8eba2cd174f
float3 rgb2hsvl(float3 c, uint model)
{
    static const float4 K = { 0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0 };
    const float4
		p = c.b > c.g ? float4(c.bg, K.wz) : float4(c.gb, K.xy),
    	q = p.x > c.r ? float4(p.xyw, c.r) : float4(c.r, p.yzx);
    const float d = q.x - min(q.w, q.y);
	float3 ret = { d > 0 ? abs(q.z + (q.w - q.y) / (6 * d)) : -32768.0, d, q.x };

	if (model >= 2) {
		ret.z -= ret.y / 2;
		if (model == 2) {
			const float u = 2 * min(ret.z, 1 - ret.z);
			ret.y = u != 0 ? ret.y / u : 0;
		}
	}
	else if (model == 0)
		ret.y = ret.z != 0 ? ret.y / ret.z : 0;
	return ret;
}
float4 to_hsvl(float4 pos : SV_Position) : SV_Target
{
	float4 col = src.Load(int3(pos.xy, 0));
	col.xyz = rgb2hsvl(col.a > 0 ? col.rgb / col.a : 0, model_f);
	return col;
}
]]
--[[pixelshader@stats_h:
Texture2D src : register(t0);
cbuffer constant0 : register(b0) {
	float width_f;
};
float4 stats_h(float4 pos : SV_Position) : SV_Target
{
	static const int width = int(width_f);
	const int y = int(pos.y);
	const float lbd = (int(pos.x) & 0xff) == 0 ? -4096.0 : floor(pos.x) / 256.0,
		ubd = pos.x > 255 ? +65536.0 : (floor(pos.x) + 1) / 256.0;
	float4 sum = 0;
	for (int x = 0; x < width; x++) {
		const float4 c = src.Load(int3(x, y, 0));
		const float4 wt = float4(c.aaa, 1.0);
		sum += lbd <= c && c < ubd ? wt : 0;
	}
	return sum * (256 * 128) / width_f;
}
]]
--[[pixelshader@stats_h_wt:
Texture2D src : register(t0);
cbuffer constant0 : register(b0) {
	float width_f, wt_src_f, wt_dst_f;
};
float4 stats_h_wt(float4 pos : SV_Position) : SV_Target
{
	static const int width = int(width_f);
	static const uint wt_src = uint(wt_src_f), wt_dst = uint(wt_dst_f);
	const int y = int(pos.y);
	const float lbd = (int(pos.x) & 0xff) == 0 ? -4096.0 : floor(pos.x) / 256.0,
		ubd = pos.x > 255 ? +65536.0 : (floor(pos.x) + 1) / 256.0;
	float4 sum = 0;
	for (int x = 0; x < width; x++) {
		const float4 c = src.Load(int3(x, y, 0));
		const float C[4] = { c.r, c.g, c.b, c.a };
		float W[4] = { c.a, c.a, c.a, 1.0 };
		W[wt_dst] *= C[wt_src];
		const float4 wt = { W[0], W[1], W[2], W[3] };
		sum += lbd <= c && c < ubd ? wt : 0;
	}
	return sum * (256 * 128) / width_f;
}
]]
--[[pixelshader@stats_v:
Texture2D src : register(t0);
cbuffer constant0 : register(b0) {
	float height_f;
};
float4 stats_v(float4 pos : SV_Position) : SV_Target
{
	static const int height = int(height_f);
	const int x = int(pos.x);
	float4 sum = 0;
	for (int y = 0; y < height; y++) sum += src.Load(int3(x, y, 0));
	return sum / height_f;
}
]]
--[[pixelshader@norm_stat:
Texture2D src : register(t0);
float4 norm_stat(float4 pos : SV_Position) : SV_Target
{
	const int x = int(pos.x);
	return 32768.0 * src.Load(int3(x, 0, 0)) / max(src.Load(int3(256, 0, 0)), 4096.0);
}
]]
--[[pixelshader@mollify:
Texture2D src : register(t0);
cbuffer constant0 : register(b0) {
	float span_f;
};
float4 mollify(float4 pos : SV_Position) : SV_Target
{
	static const uint span = int(span_f);
	static const int dx0 = int(span >> 1), dx1 = int(span) - dx0;
	const int x0 = int(pos.x);
	float4 sum = 0;
	for (int dx = -dx0; dx < dx1; dx++)
		sum += src.Load(int3(x0 + dx, 0, 0));
	return sum / (min(x0, dx0) + min(256 - x0, dx1));
}
]]
--[[pixelshader@draw:
Texture2D src : register(t0);
cbuffer constant0 : register(b0) {
	float2 size_f;
	float channels_f;
	float scale, logarithmic_f, hue_channel_f;
	float4 col_grid, col_back;
	float4 colors[8];
};
static const uint2 size = uint2(size_f);
static const uint channels = uint(channels_f);
static const int hue_channel = int(hue_channel_f);
float4 draw(float4 pos : SV_Position) : SV_Target
{
	// clip blanks and determine the channel.
	uint2 p = uint2(pos.xy);
	if (p.x < 8 || p.x >= size.x + 8) { return col_back; }
	p.x -= 8;
	uint ch = p.y / (size.y + 8);
	p.y -= ch * (size.y + 8);
	if (ch >= channels) { return col_back; }

	// collect data.
	const uint section = floor(256 * p.x / size_f.x);
	const float thresh = 1 - (int(p.y) - 8) / size_f.y;
	float val = src.Load(int3(section, 0, 0))[ch] / 128;

	// correct data.
	val = val > 0 && logarithmic_f > 0 ?
		(scale / 16) * log2(val) + 0.75 :
		(scale / 2) * val;

	// compare data.
	if (val <= thresh) {
		if (p.y >= 8 &&
			(p.x == 0 || p.x == size.x - 1 || p.y == size.y + 7))
			return col_grid + (1 - col_grid.a) * col_back;
		return col_back;
	}

	// determine the color.
	float4 col = colors[
		hue_channel < 0 ? 2 * ch + (section >> 7) :
		int(ch) == hue_channel ? ((6 * ((section + 21) & 255)) >> 8) : 6];
	col *= saturate(p.y / 8.0);
	col += (1 - col.a) * col_back;
	return col;
}
]]
local width,height,target,target_layer,space,hue_weighted,alpha,amplify,scale,mollify,col_draw,col_back,alpha_back,colorful,grid,pos_labels,hide_mode=width,height,target,target_layer,space,hue_weighted,alpha,amplify,scale,mollify,col_draw,col_back,alpha_back,colorful,grid,pos_labels,hide_mode;
local obj, math, bit = obj, math, bit;
if (hide_mode >= 1 and obj.getinfo("saving")) or
	(hide_mode == 2 and not obj.getoption("gui")) then return end

-- normalize parameters.
width = math.max(math.floor(0.5 + width), 256);
height = math.max(math.floor(0.5 + height), 16);
target = math.min(math.max(math.floor(0.5 + target), 0), 3);
space = math.min(math.max(math.floor(0.5 + space), 0), 11);
amplify = math.min(math.max(amplify / 100, 0), 16);
scale = math.min(math.max(math.floor(0.5 + scale), 0), 1);
mollify = math.min(math.max(math.floor(0.5 + mollify), 0), 15);
col_draw = math.floor(0.5 + col_draw) % 2 ^ 24;
col_back = math.floor(0.5 + col_back) % 2 ^ 24;
alpha_back = math.min(math.max(1 - alpha_back / 100, 0), 1);
pos_labels = math.min(math.max(pos_labels / 100, -1), 1);

-- load the target image.
if target < 2 then
	obj.load("framebuffer", 0, 0, obj.screen_w, obj.screen_h, target > 0);
else
	local layer = target == 2 and 0 or obj.layer;
	layer = layer + math.floor((tonumber(target_layer) or 0) + 0.5);
	if layer <= 0 or layer == obj.layer then return end
	if not obj.getvalue("layer"..layer) then return end
	obj.load("layer", layer, true);
	if obj.w <= 0 or obj.h <= 0 then return end
end

-- convert to the destination color space.
local wt_src, wt_dst = nil, nil;
if space < 3 then
	local shader =
		space == 0 and "to_xyz" or
		space == 1 and "un_alpha" or
		"to_srgb";
	obj.pixelshader(shader, "object", "object");
elseif space < 5 then
	obj.pixelshader("to_oklab", "object", "object", {
		space == 3 and 0 or 1
	});
	if space > 3 then wt_src, wt_dst = 1, 2 end
elseif space < 8 then
	local bt = space - 5;
	local M = bt == 0 and { -- BT.601.
		0.299, 0.587, 0.114;
		-0.16873589164786, -0.33126410835214, 0.5;
		0.5, -0.41868758915835, -0.081312410841655;
	} or bt == 1 and { -- BT.709.
		0.2126, 0.7152, 0.0722;
		-0.11457210605734, -0.38542789394266, 0.5;
		0.5, -0.45415290830582, -0.045847091694183;
	} or { -- BT.2020. (same as BT.2100.)
		0.2627, 0.678, 0.0593;
		-0.13963006271925, -0.36036993728075, 0.5;
		0.5, -0.45978570459786, -0.040214295402143;
	}
	obj.pixelshader("to_yuv", "object", "object", {
		M[1], M[4], M[7], 0;
		M[2], M[5], M[8], 0;
		M[3], M[6], M[9];
	});
else
	obj.pixelshader("to_hsvl", "object", "object", { space - 8 });
	wt_src, wt_dst = 1, 0;
end

-- take statistics.
local w, h = obj.w, obj.h;
obj.setoption("drawtarget", "tempbuffer", 257, h);
obj.pixelshader((hue_weighted and wt_src) and "stats_h_wt" or "stats_h",
	"tempbuffer", "object", { w, wt_src, wt_dst });
obj.copybuffer("object", "tempbuffer");
obj.setoption("drawtarget", "tempbuffer", 257, 1);
obj.pixelshader("stats_v", "tempbuffer", "object", { h });
obj.copybuffer("object", "tempbuffer");
obj.setoption("drawtarget", "tempbuffer", 256, 1);
obj.pixelshader("norm_stat", "tempbuffer", "object");
obj.copybuffer("object", "tempbuffer");

-- mollify the graph.
if mollify > 0 then obj.pixelshader("mollify", "object", "tempbuffer", { mollify + 1 }) end

-- determine the colors.
local col_r, col_g, col_b =
	bit.band(col_draw, 0xff0000) / 0xff0000,
	bit.band(col_draw, 0x00ff00) / 0x00ff00,
	bit.band(col_draw, 0x0000ff) / 0x0000ff;
local bak_r, bak_g, bak_b =
	alpha_back * bit.band(col_back, 0xff0000) / 0xff0000,
	alpha_back * bit.band(col_back, 0x00ff00) / 0x00ff00,
	alpha_back * bit.band(col_back, 0x0000ff) / 0x0000ff;
local grd_r, grd_g, grd_b, grd_a;
grd_a = grid and 0.5 or 0;
grd_r, grd_g, grd_b, grd_a =
	grd_a * col_r + (1 - grd_a) * bak_r,
	grd_a * col_g + (1 - grd_a) * bak_g,
	grd_a * col_b + (1 - grd_a) * bak_b,
	grd_a + alpha_back - grd_a * alpha_back;
local colors = {
	col_r, col_g, col_b, 1; col_r, col_g, col_b, 1;
	col_r, col_g, col_b, 1; col_r, col_g, col_b, 1;
	col_r, col_g, col_b, 1; col_r, col_g, col_b, 1;
	col_r, col_g, col_b, 1; col_r, col_g, col_b, 1;
}
local hue_channel = -1;
if colorful then
	if space < 3 then
		-- XYZ and RGB
		for i = 0, 1 do
			colors[8 * 0 + 4 * i + 1], colors[8 * 0 + 4 * i + 2], colors[8 * 0 + 4 * i + 3] = 1, 0, 0;
			colors[8 * 1 + 4 * i + 1], colors[8 * 1 + 4 * i + 2], colors[8 * 1 + 4 * i + 3] = 0, 1, 0;
			colors[8 * 2 + 4 * i + 1], colors[8 * 2 + 4 * i + 2], colors[8 * 2 + 4 * i + 3] = 0, 0, 1;
		end
	elseif space == 3 then
		-- Oklab
		colors[8 * 1 + 0 + 1], colors[8 * 1 + 0 + 2], colors[8 * 1 + 0 + 3] = 0, 1, 211 / 255;
		colors[8 * 1 + 4 + 1], colors[8 * 1 + 4 + 2], colors[8 * 1 + 4 + 3] = 1, 0, 137 / 255;

		colors[8 * 2 + 0 + 1], colors[8 * 2 + 0 + 2], colors[8 * 2 + 0 + 3] = 47 / 255, 0, 1;
		colors[8 * 2 + 4 + 1], colors[8 * 2 + 4 + 2], colors[8 * 2 + 4 + 3] = 1, 203 / 255, 0;
	elseif space == 4 then
		-- OKLCh
		colors[4 * 0 + 1], colors[4 * 0 + 2], colors[4 * 0 + 3] = 1, 0, 137 / 255;
		colors[4 * 1 + 1], colors[4 * 1 + 2], colors[4 * 1 + 3] = 1, 119 / 255, 0;
		colors[4 * 2 + 1], colors[4 * 2 + 2], colors[4 * 2 + 3] = 214 / 255, 1, 0;
		colors[4 * 3 + 1], colors[4 * 3 + 2], colors[4 * 3 + 3] = 0, 1, 211 / 255;
		colors[4 * 4 + 1], colors[4 * 4 + 2], colors[4 * 4 + 3] = 0, 173 / 255, 1;
		colors[4 * 5 + 1], colors[4 * 5 + 2], colors[4 * 5 + 3] = 150 / 255, 0, 1;
		hue_channel = 2;
	elseif space < 8 then
		-- YUV
		-- use the colors for BT.601.
		colors[8 * 1 + 0 + 1], colors[8 * 1 + 0 + 2], colors[8 * 1 + 0 + 3] = 214 / 255, 1, 0;
		colors[8 * 1 + 4 + 1], colors[8 * 1 + 4 + 2], colors[8 * 1 + 4 + 3] = 41 / 255, 0, 1;

		colors[8 * 2 + 0 + 1], colors[8 * 2 + 0 + 2], colors[8 * 2 + 0 + 3] = 0, 1, 169 / 255;
		colors[8 * 2 + 4 + 1], colors[8 * 2 + 4 + 2], colors[8 * 2 + 4 + 3] = 1, 0, 86 / 255;
	else
		-- HSV / HSL
		colors[4 * 0 + 1], colors[4 * 0 + 2], colors[4 * 0 + 3] = 1, 0, 0;
		colors[4 * 1 + 1], colors[4 * 1 + 2], colors[4 * 1 + 3] = 1, 1, 0;
		colors[4 * 2 + 1], colors[4 * 2 + 2], colors[4 * 2 + 3] = 0, 1, 0;
		colors[4 * 3 + 1], colors[4 * 3 + 2], colors[4 * 3 + 3] = 0, 1, 1;
		colors[4 * 4 + 1], colors[4 * 4 + 2], colors[4 * 4 + 3] = 0, 0, 1;
		colors[4 * 5 + 1], colors[4 * 5 + 2], colors[4 * 5 + 3] = 1, 0, 1;
		hue_channel = 0;
	end
end

-- draw the graph.
obj.setoption("drawtarget", "tempbuffer", width + 16, (height + 8) * (alpha and 4 or 3) + 8);
obj.pixelshader("draw", "tempbuffer", "object", {
	width, height;
	alpha and 4 or 3;
	amplify; scale > 0 and 1 or 0;
	hue_channel; 0, 0;
	grd_r, grd_g, grd_b, grd_a;
	bak_r, bak_g, bak_b, alpha_back;
	unpack(colors)
});

-- draw labels.
if -1 < pos_labels and pos_labels < 1 then
	local labels =
		space == 0 and { "X", "Y", "Z" } or
		(space == 1 or space == 2) and { "R", "G", "B" } or
		space == 3 and { "L", "a", "b" } or
		space == 4 and { "L", "C", "H" } or
		(5 <= space and space <= 7) and { "Y", "U", "V" } or
		(space == 8 or space == 9) and { "H", "S", "V" } or
		{ "H", "S", "L" };
	if alpha then labels[4] = "A" end
	obj.setoption("blend", "diff");
	obj.setfont("Consolas", math.min(width / 8, height / 3), 0, 0xffffff);
	for i, c in ipairs(labels) do
		obj.load("text", "<s,,B>"..c);
		obj.draw((width - obj.w) * pos_labels / 2, (i - (alpha and 2.5 or 2)) * (8 + height));
	end
	obj.setoption("blend", "none");
end

obj.load("tempbuffer");
